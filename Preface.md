# Preface

Most developers learn Dart by copying Flutter snippets—then hit a wall when their app crashes with a null error, or their widgets rebuild uncontrollably, or they can’t decide between `final` and `const`. They know *how* to write Dart, but not *why* it works that way.

This book exists to fix that.

**"Dart: The Logic Behind Flutter"** isn’t another syntax reference. It’s a guided journey into the **thinking patterns** that make Dart powerful—and that make Flutter possible. We start from scratch, not assuming prior programming knowledge beyond curiosity, and build upward with one goal: **logical clarity**.

You’ll learn:
- Why Dart’s type system prevents bugs before they happen  
- How object-oriented design models real-world behavior  
- When (and why) to use async, streams, or immutable data  
- Which Dart features Flutter relies on—and which you can ignore  

Every chapter answers three questions:
> 1. **What problem does this solve?**  
> 2. **How does Dart solve it elegantly?**  
> 3. **How would I use this in a real Flutter app?**

This book is **opinionated**: we skip academic tangents and legacy patterns. We focus only on what helps you **think better, code cleaner, and build faster**.

If you’re ready to stop guessing and start reasoning—welcome. Let’s begin.

— The Author  
*Abdullah Khaled Elbokl*

# Table of Contents

## PART 1: Programming Foundations with Dart

- Chapter 1: Thinking Like a Programmer  
  - Input → Process → Output  
  - Algorithms & logic flow  
  - Problem decomposition  

- Chapter 2: Variables & Data Types  
  - `var`, `final`, `const`  
  - Primitive types  
  - Memory thinking  

- Chapter 3: Control Flow  
  - `if` / `else`  
  - `switch`  
  - Logical operators  

- Chapter 4: Loops & Iteration  
  - `for`, `while`, `do-while`  
  - Loop patterns  
  - Common mistakes  

- Chapter 5: Functions & Reusability  
  - Parameters  
  - Return values  
  - Arrow functions  

## PART 2: Working with Data

- Chapter 6: Collections  
  - `List`  
  - `Set`  
  - `Map`  
  - Iteration techniques  

- Chapter 7: Null Safety (Critical Dart Feature)  
  - Nullable vs non-nullable  
  - Null-aware operators  
  - Defensive programming  

- Chapter 8: Error Handling  
  - `try` / `catch`  
  - Custom exceptions  
  - Failure-safe logic  

## PART 3: Object-Oriented Programming (OOP)

- Chapter 9: Introduction to OOP  
  - Why OOP exists  
  - Real-world modeling  
  - Objects vs data  

- Chapter 10: Classes & Objects  
  - Class structure  
  - Constructors  
  - Fields & methods  

- Chapter 11: Encapsulation  
  - Private members  
  - Getters & setters  
  - Data protection  

- Chapter 12: Inheritance  
  - `extends`  
  - `super`  
  - Method overriding  

- Chapter 13: Polymorphism  
  - Base class references  
  - Overriding behavior  
  - Real use cases  

- Chapter 14: Abstraction  
  - Abstract classes  
  - Interfaces in Dart  
  - When to use abstraction  

- Chapter 15: Composition vs Inheritance  
  - "Has-a" vs "Is-a"  
  - Cleaner design choices  

## PART 4: Advanced Dart Concepts

- Chapter 16: Enums & Extensions  
  - Enums for state  
  - Extension methods  
  - Cleaner APIs  

- Chapter 17: Generics  
  - Type safety  
  - Reusable structures  

- Chapter 18: Mixins  
  - Code reuse without inheritance  
  - Flutter use cases  

- Chapter 19: Immutability  
  - `final` vs `const`  
  - Immutable objects  
  - Safer state  

## PART 5: Async & Performance

- Chapter 20: Asynchronous Programming  
  - `Future`  
  - `async` / `await`  
  - Common async patterns  

- Chapter 21: Streams  
  - Single vs multiple events  
  - Listening patterns  

- Chapter 22: Isolates (Conceptual)  
  - Why isolates exist  
  - Performance thinking  

## PART 6: Dart for Flutter Developers

- Chapter 23: Dart Patterns Used in Flutter  
  - Widget constructors  
  - Callbacks  
  - State logic  

- Chapter 24: Clean Code for Flutter  
  - Naming  
  - Small classes  
  - Separation of concerns  

- Chapter 25: Common Dart Mistakes in Flutter  
  - Rebuild issues  
  - Null misuse  
  - Overengineering  

## PART 7: Problem-Solving Section

- Chapter 26: Logic Challenges  
  - Conditions-based problems  
  - Loop-based problems  
  - Collection manipulation  

- Chapter 27: Mini Projects  
  - Counter logic  
  - Cart system  
  - Simple validation engine
